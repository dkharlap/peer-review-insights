<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GitHub PR Insights</title>
  <!-- For production, use Tailwind via npm and build CSS locally. Example: -->
  <!-- <link href="dist/tailwind.css" rel="stylesheet"> -->
  <!-- Remove the CDN script below for production use. -->
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* Keep original table layout helpers */
    html { scrollbar-gutter: stable; }
    #results table { table-layout: auto; }
    #results table th:not(:first-child),
    #results table td:not(:first-child) { white-space: nowrap; width:1%; }
    #results table th:first-child,
    #results table td:first-child { width:auto; }
    #results table th:nth-child(2),
    #results table td:nth-child(2) { min-width:80px; width:80px; max-width:80px; white-space:nowrap; }
    /* Remove dark mode specific panel style; permanent dark backdrop if desired for overlay */
    #progressPanel > div { background:#ffffff; color:#1f2937; }
    /* Page background now always dark gradient */
    body.app-dark-bg { background: radial-gradient(circle at 25% 20%, #1f2937 0%, #111827 55%, #0b0f19 100%); }
    /* Peer review / PR modal title visibility */
    #prModalTitle, #progressPanel .overlay-title {
      color:#0f172a; /* deep slate for contrast on white card */
      font-weight:600;
      position:relative;
      letter-spacing:.5px;
    }
  </style>
</head>
<body class="app-dark-bg min-h-screen text-gray-100 flex flex-col items-center relative overflow-y-scroll">

  <!-- Background image -->
  <div class="fixed inset-0 pointer-events-none">
    <img src="https://images.unsplash.com/photo-1501785888041-af3ef285b470" 
         alt="Background" 
         class="w-full h-full object-cover opacity-10 select-none">
  </div>

  <!-- Content -->
  <div class="relative z-10 w-full max-w-5xl p-6">

    <!-- Header -->
    <header class="text-center mb-6">
      <h1 class="text-3xl font-bold text-white">Developer Velocity</h1>
      <p class="mt-2 text-gray-300">
        This page analyzes GitHub pull requests and peer reviews for selected repositories and date ranges.
        It shows per-user and per-month stats including PR counts, approvals, merges, reviews, average comments, and estimated review times.
      </p>
      <p class="text-gray-400">
        <br/>
        <b>NOTE: no data is sent to our servers; all processing is done in your browser and GitHub.</b>
      </p>
    </header>

    <!-- Form -->
    <form id="prForm" class="bg-white text-gray-800 shadow-lg rounded p-6 md:p-8 grid gap-4 md:gap-6 w-full">
      <input type="text" id="token" placeholder="GitHub Token" required
             class="border p-3 rounded w-full focus:ring-2 focus:ring-blue-400">
      <input type="text" id="repo" placeholder="Repositories (e.g. owner1/repo1, owner2/repo2) or leave blank for all private repos"
             class="border p-3 rounded w-full focus:ring-2 focus:ring-blue-400">
      <input type="date" id="dateFrom" class="border p-3 rounded w-full focus:ring-2 focus:ring-blue-400">
      <input type="date" id="dateTo" class="border p-3 rounded w-full focus:ring-2 focus:ring-blue-400">
      <button type="submit" 
              class="bg-blue-600 text-white py-3 px-6 rounded hover:bg-blue-700 transition w-full md:w-auto">
        Get Developer Velocity
      </button>
    </form>

    <!-- Results -->
    <div id="results" class="mt-8 bg-white text-gray-800 shadow-md rounded p-4 overflow-x-auto hidden">
      <!-- PR Table -->
      <div id="prTablePanel" class="mb-8 hidden">
        <h2 class="text-xl font-semibold mb-2 text-blue-900">Pull Requests</h2>
        <table class="w-full border-collapse table-auto">
          <thead>
            <tr class="bg-blue-600 text-white text-left">
              <th class="p-3">User</th>
              <th class="p-3">Month</th>
              <th class="p-3">Submitted</th>
              <th class="p-3">Merged</th>
              <th class="p-3">Updates</th>
              <th class="p-3">Lines Changed</th>
              <th class="p-3">Avg Merge (hrs)</th>
            </tr>
          </thead>
          <tbody id="prTableBody"></tbody>
        </table>
      </div>
      <!-- Peer Review Table -->
      <div id="reviewTablePanel" class="hidden">
        <h2 class="text-xl font-semibold mb-2 text-blue-900">Peer Reviews</h2>
        <table class="w-full border-collapse table-auto">
          <thead>
            <tr class="bg-blue-600 text-white text-left">
              <th class="p-3">User</th>
              <th class="p-3">Month</th>
              <th class="p-3">Reviewed</th>
              <th class="p-3">Avg Comments</th>
              <th class="p-3">Avg Review (min)</th>
              <th class="p-3">Avg Actioned Comments</th>
            </tr>
          </thead>
          <tbody id="reviewTableBody"></tbody>
        </table>
      </div>
    </div>

    <!-- Progress overlay -->
    <div id="progressPanel" class="fixed inset-0 z-50 hidden items-center justify-center bg-black/30">
      <div class="bg-white shadow-2xl rounded p-6 w-full max-w-lg"
           style="position:absolute;left:50%;top:0;transform:translateX(-50%);margin-top:200px;">
  <div class="text-lg font-semibold mb-2 overlay-title">Working…</div>
        <div id="progressStatus" class="text-sm text-gray-700 mb-1">Preparing…</div>
        <div class="w-full bg-gray-200 rounded h-3 overflow-hidden">
          <div id="overallBar" class="h-3 bg-blue-600" style="width: 0%"></div>
        </div>
        <div class="flex justify-between text-xs text-gray-600 mt-1">
          <span>Overall</span>
          <span id="overallPct">0%</span>
        </div>
        <div id="subLabel" class="text-sm text-gray-700 mt-4 mb-1">Subtask</div>
        <div class="w-full bg-gray-200 rounded h-3 overflow-hidden">
          <div id="subBar" class="h-3 bg-emerald-600" style="width: 0%"></div>
        </div>
        <div class="flex justify-between text-xs text-gray-600 mt-1">
          <span id="progressDetail">Starting…</span>
          <span id="subPct">0%</span>
        </div>
        <div id="apiUsage" class="text-xs text-gray-500 mt-4 mb-2"></div>
      </div>
    </div>

    <!-- Modal for PR list -->
    <div id="prModal" class="fixed inset-0 z-50 hidden items-center justify-center bg-black/40">
      <div class="bg-white shadow-2xl rounded p-6 w-full max-w-2xl">
        <div class="flex justify-between items-center mb-4">
          <div class="text-lg font-semibold overlay-title" id="prModalTitle">Related Pull Requests</div>
          <button id="prModalClose" class="text-gray-500 hover:text-gray-800 text-xl">&times;</button>
        </div>
        <div id="prModalContent" class="space-y-2 overflow-y-auto" style="max-height:60vh"></div>
      </div>
    </div>

  </div>

  <script>
    // Default date logic: if empty, dateTo = today; dateFrom = first of current month if today > 15th, else first of previous month
    document.addEventListener('DOMContentLoaded', () => {
      const fromEl = document.getElementById('dateFrom');
      const toEl = document.getElementById('dateTo');
      if (fromEl && toEl && !fromEl.value && !toEl.value) {
        const today = new Date();
        const yyyy = today.getFullYear();
        const mm = String(today.getMonth() + 1).padStart(2, '0');
        const dd = String(today.getDate()).padStart(2, '0');
        // dateTo -> today
        toEl.value = `${yyyy}-${mm}-${dd}`;
        // Compute dateFrom
        let fromDate;
        if (today.getDate() > 15) {
          fromDate = new Date(yyyy, today.getMonth(), 1);
        } else {
          // previous month
            const prevMonth = new Date(yyyy, today.getMonth() - 1, 1);
            fromDate = prevMonth;
        }
        const fyyyy = fromDate.getFullYear();
        const fmm = String(fromDate.getMonth() + 1).padStart(2, '0');
        const fdd = '01';
        fromEl.value = `${fyyyy}-${fmm}-${fdd}`;
      }
    });
    async function fetchAllPRs(token, reposArray, progress, headers, totals, updateOverall) {
      let prs = [];

      for (let i = 0; i < reposArray.length; i++) {
        const repo = reposArray[i];
        let page = 1;
        let repoLastPage = null;
        let repoFetchedPages = 0;
        while (true) {
          const url = new URL(`https://api.github.com/repos/${repo}/pulls`);
          url.searchParams.set("state", "all");
          url.searchParams.set("per_page", "100");
          url.searchParams.set("page", page);
          progress?.setDetail(`Repo ${i + 1}/${reposArray.length}: ${repo} — page ${page}${repoLastPage ? " of " + repoLastPage : ""}`);
          const resp = await fetch(url, { headers });
          progress?.incApiUsage(resp);
          if (!resp.ok) throw new Error(`GitHub API error for ${repo}: ${resp.status} ${resp.statusText}`);
          if (page === 1) {
            const last = parseLastPage(resp.headers.get("Link"));
            if (last) {
              repoLastPage = last;
              totals.totalPages += last;
            } else {
              totals.totalPages += 1;
            }
          }
          const data = await resp.json();
          for (const pr of data) pr._repo = repo;
          prs = prs.concat(data);
          repoFetchedPages++;
          totals.fetchedPages++;
          progress?.setSub(repoFetchedPages, repoLastPage ?? repoFetchedPages);
          if (typeof updateOverall === "function") updateOverall();

          if (data.length < 100) break;
          if (!repoLastPage) totals.totalPages += 1;
          page++;
        }
      }
      return prs;
    }

    async function fetchPRReviewsAndComments(prs, headers, progress, totals, updateOverall) {
      const approvedSet = new Set();
      const reviewsDoneByUserMonth = {};
      const logicalReviewsByUserMonth = {};
      const commentsByUserMonth = {};
      const reviewTimeByUserMonth = {};
      const prMapByUserMonth = {};
      const approvedMapByUserMonth = {};
      const mergedMapByUserMonth = {};
      const reviewedMapByUserMonth = {};
      const actionedCommentsByUserMonth = {}; // NEW

      for (let idx = 0; idx < prs.length; idx++) {
        const pr = prs[idx];
        // Fetch reviews
        const reviewsResp = await fetch(`https://api.github.com/repos/${pr._repo}/pulls/${pr.number}/reviews`, { headers });
        progress?.incApiUsage(reviewsResp);
        let reviews = [];
        if (reviewsResp.ok) {
          reviews = await reviewsResp.json();
          pr._reviews = reviews;
        }
        // Fetch review comments
        const commentsResp = await fetch(`https://api.github.com/repos/${pr._repo}/pulls/${pr.number}/comments`, { headers });
        progress?.incApiUsage(commentsResp);
        let reviewComments = [];
        if (commentsResp.ok) reviewComments = await commentsResp.json();

        // Build changed line set (final merged state) for actioned detection
        let changedLines = new Set();
        if (pr.merged_at) {
          try {
            const filesResp = await fetch(pr.url + "/files", { headers });
            progress?.incApiUsage(filesResp);
            if (filesResp.ok) {
              const files = await filesResp.json();
              let totalChanged = 0; // only track total changed lines now
              for (const file of files) {
                const fileChanges = (file.changes != null) ? file.changes : 0;
                totalChanged += fileChanges;
                if (!file.patch) continue; // still need patch for actioned detection
                const lines = file.patch.split("\n");
                let newLine = 0;
                for (const line of lines) {
                  if (line.startsWith("@@")) {
                    const m = line.match(/@@ -\d+(?:,\d+)? \+(\d+)(?:,(\d+))? @@/);
                    if (m) newLine = parseInt(m[1], 10) - 1;
                  } else if (line.startsWith("+")) {
                    changedLines.add(newLine);
                    newLine++;
                  } else if (line.startsWith("-")) {
                    // deletion does not increment newLine
                  } else {
                    newLine++;
                  }
                }
              }
              pr._linesChanged = totalChanged;
            }
          } catch {}
        }

        if (reviews.some(r => r.state === "APPROVED")) approvedSet.add(`${pr._repo}#${pr.number}`);
        const prMonth = pr.created_at.slice(0, 7);

        // Group reviews by user
        const reviewsByUser = {};
        for (const r of reviews) {
          if (r.user?.login && r.user.login !== pr.user?.login) {
            (reviewsByUser[r.user.login] = reviewsByUser[r.user.login] || []).push(r);
          }
        }
        // Group comments by user
        const commentsByUser = {};
        for (const c of reviewComments) {
          if (c.user?.login) (commentsByUser[c.user.login] = commentsByUser[c.user.login] || []).push(c);
        }

        // Build logical review groups per reviewer
        for (const reviewer in reviewsByUser) {
          const userReviews = reviewsByUser[reviewer].slice().sort((a,b) => new Date(a.submitted_at) - new Date(b.submitted_at));
          let groups = []; let group = []; let lastTime = null;
          for (const rev of userReviews) {
            const t = new Date(rev.submitted_at);
            if (!lastTime || (t - lastTime) > 20 * 60 * 1000) { if (group.length) groups.push(group); group = [rev]; } else group.push(rev); lastTime = t;
          }
          if (group.length) groups.push(group);

          logicalReviewsByUserMonth[reviewer] = logicalReviewsByUserMonth[reviewer] || {}; 
          commentsByUserMonth[reviewer] = commentsByUserMonth[reviewer] || {}; 
          reviewTimeByUserMonth[reviewer] = reviewTimeByUserMonth[reviewer] || {}; 
          actionedCommentsByUserMonth[reviewer] = actionedCommentsByUserMonth[reviewer] || {}; 
          logicalReviewsByUserMonth[reviewer][prMonth] = (logicalReviewsByUserMonth[reviewer][prMonth] || 0) + groups.length;
          commentsByUserMonth[reviewer][prMonth] = commentsByUserMonth[reviewer][prMonth] || 0;
          reviewTimeByUserMonth[reviewer][prMonth] = reviewTimeByUserMonth[reviewer][prMonth] || 0;
          actionedCommentsByUserMonth[reviewer][prMonth] = actionedCommentsByUserMonth[reviewer][prMonth] || 0;

          for (const g of groups) {
            let commentTimes = []; let commentCount = 0; let actionedCount = 0;
            let windowStart, windowEnd;
            if (g.length === 1) { windowStart = windowEnd = new Date(g[0].submitted_at); }
            else { windowStart = new Date(g[0].submitted_at); windowEnd = new Date(g[g.length-1].submitted_at); }

            if (commentsByUser[reviewer]) {
              for (const c of commentsByUser[reviewer]) {
                const ct = new Date(c.created_at);
                if (windowStart && windowEnd && ct >= windowStart && ct <= windowEnd) {
                  commentCount++; commentTimes.push(ct);
                  if (pr.merged_at && c.position != null && changedLines.size) {
                    // check +/- 10 lines around comment position
                    for (let ln = c.position - 10; ln <= c.position + 10; ln++) {
                      if (changedLines.has(ln)) { actionedCount++; break; }
                    }
                  }
                }
              }
            }
            for (const rv of g) { if (rv.body && rv.body.trim()) { commentCount++; commentTimes.push(new Date(rv.submitted_at)); } }
            commentsByUserMonth[reviewer][prMonth] += commentCount;
            actionedCommentsByUserMonth[reviewer][prMonth] += actionedCount;

            let durationMin; let reviewWindowStart;
            if (commentTimes.length === 0) { durationMin = 3; reviewWindowStart = new Date(windowStart - 3*60000); }
            else if (commentTimes.length === 1) { durationMin = 5; reviewWindowStart = new Date(commentTimes[0] - 5*60000); }
            else { const minT = Math.min(...commentTimes.map(d=>d.getTime())); const maxT = Math.max(...commentTimes.map(d=>d.getTime())); durationMin = 5 + (maxT - minT)/60000; reviewWindowStart = new Date(minT - 5*60000); }
            reviewTimeByUserMonth[reviewer][prMonth] += durationMin;
            (pr._reviewWindows = pr._reviewWindows || []).push({ reviewer, group: g, reviewWindowStart, reviewDurationMin: durationMin, groupStart: windowStart, groupEnd: windowEnd });
          }
          reviewsDoneByUserMonth[reviewer] = reviewsDoneByUserMonth[reviewer] || {}; 
          reviewsDoneByUserMonth[reviewer][prMonth] = logicalReviewsByUserMonth[reviewer][prMonth];
        }

        // Submitter mappings
        const submitter = pr.user?.login || "unknown";
        (prMapByUserMonth[submitter] = prMapByUserMonth[submitter] || {});
        (prMapByUserMonth[submitter][prMonth] = prMapByUserMonth[submitter][prMonth] || []).push(pr);
        if (reviews.some(r => r.state === "APPROVED")) {
          (approvedMapByUserMonth[submitter] = approvedMapByUserMonth[submitter] || {});
          (approvedMapByUserMonth[submitter][prMonth] = approvedMapByUserMonth[submitter][prMonth] || []).push(pr);
        }
        if (pr.merged_at) {
          (mergedMapByUserMonth[submitter] = mergedMapByUserMonth[submitter] || {});
          (mergedMapByUserMonth[submitter][prMonth] = mergedMapByUserMonth[submitter][prMonth] || []).push(pr);
        }
        for (const r of reviews) {
          if (r.user?.login && r.user.login !== submitter) {
            (reviewedMapByUserMonth[r.user.login] = reviewedMapByUserMonth[r.user.login] || {});
            (reviewedMapByUserMonth[r.user.login][prMonth] = reviewedMapByUserMonth[r.user.login][prMonth] || []).push({ pr, review: r });
          }
        }
        totals.fetchedReviews++;
        progress?.setDetail(`${Math.min(totals.fetchedReviews, totals.totalReviews)} of ${totals.totalReviews} reviews fetched`);
        progress?.setSub(totals.fetchedReviews, totals.totalReviews);
        updateOverall?.();
      }

      return { approvedSet, reviewsDoneByUserMonth, logicalReviewsByUserMonth, commentsByUserMonth, reviewTimeByUserMonth, prMapByUserMonth, approvedMapByUserMonth, mergedMapByUserMonth, reviewedMapByUserMonth, actionedCommentsByUserMonth };
    }

    function filterPRsByDate(prs, dateFrom, dateTo) {
      if (!dateFrom && !dateTo) return prs;
      const from = dateFrom ? new Date(dateFrom) : null;
      const to = dateTo ? new Date(dateTo) : null;
      return prs.filter(pr => {
        const created = new Date(pr.created_at);
        if (from && created < from) return false;
        if (to && created > to) return false;
        return true;
      });
    }

    function aggregateStats(prs, approvedSet) {
      const grouped = {};
      for (const pr of prs) {
        const user = pr.user?.login || "unknown";
        const month = pr.created_at.slice(0, 7);
        if (!grouped[user]) grouped[user] = {};
        if (!grouped[user][month]) grouped[user][month] = { count: 0, approved: 0, merged: 0 };
        grouped[user][month].count++;
        if (approvedSet.has(`${pr._repo}#${pr.number}`)) {
          grouped[user][month].approved++;
        }
        if (pr.merged_at) {
          grouped[user][month].merged++;
        }
      }
      return grouped;
    }

    function flattenStats(
      grouped,
      logicalReviewsByUserMonth,
      commentsByUserMonth,
      reviewTimeByUserMonth,
      prMapByUserMonth,
      approvedMapByUserMonth,
      mergedMapByUserMonth,
      reviewedMapByUserMonth,
      actionedCommentsByUserMonth
    ) {
      const rows = [];
      const allUsers = new Set([...Object.keys(grouped), ...Object.keys(logicalReviewsByUserMonth)]);
      for (const user of Array.from(allUsers).sort()) {
        const months = new Set([
          ...(grouped[user] ? Object.keys(grouped[user]) : []),
          ...(logicalReviewsByUserMonth[user] ? Object.keys(logicalReviewsByUserMonth[user]) : [])
        ]);
        for (const m of Array.from(months).sort()) {
          const mergedList = mergedMapByUserMonth[user]?.[m] || [];
          let totalMergeTime = 0, mergedCount = 0;
          for (const pr of mergedList) {
            if (pr.created_at && pr.merged_at) {
              totalMergeTime += (new Date(pr.merged_at) - new Date(pr.created_at)) / 3600000;
              mergedCount++;
            }
          }
          const avgMergeTime = mergedCount ? (totalMergeTime / mergedCount).toFixed(2) : "0.00";
          const logicalReviews = logicalReviewsByUserMonth[user]?.[m] || 0;
          const comments = commentsByUserMonth[user]?.[m] || 0;
            const actioned = actionedCommentsByUserMonth?.[user]?.[m] || 0;
          const totalReviewTime = reviewTimeByUserMonth[user]?.[m] || 0;
          const avgActioned = logicalReviews ? (actioned / logicalReviews).toFixed(2) : "0.00";
          rows.push({
            user,
            month: m,
            count: grouped[user]?.[m]?.count || 0,
            approved: grouped[user]?.[m]?.approved || 0,
            merged: grouped[user]?.[m]?.merged || 0,
            avgMergeTime,
            prList: prMapByUserMonth[user]?.[m] || [],
            approvedList: approvedMapByUserMonth[user]?.[m] || [],
            mergedList,
            updateCounts: mergedList.map(pr => pr._updateCount),
            reviewed: logicalReviews,
            avgCommentsPerReview: logicalReviews ? (comments / logicalReviews).toFixed(2) : "0.00",
            avgReviewTime: logicalReviews ? (totalReviewTime / logicalReviews).toFixed(2) : "0.00",
            reviewedList: reviewedMapByUserMonth[user]?.[m] || [],
            actionedCount: actioned,
            avgActionedComments: avgActioned
          });
        }
      }
      return rows;
    }

    // Add this helper function before getPRStats
    async function fetchUpdateCountsForMergedPRs(prs, headers) {
      for (const pr of prs) {
        if (pr.merged_at && pr.commits_url) {
          try {
            const resp = await fetch(pr.commits_url, { headers });
            if (resp.ok) {
              const commits = await resp.json();
              const created = new Date(pr.created_at);
              const merged = new Date(pr.merged_at);
              pr._updateCount = commits.filter(c => {
                const cDate = new Date(c.commit.committer.date);
                return cDate > created && cDate < merged;
              }).length;
            } else {
              pr._updateCount = null;
            }
          } catch {
            pr._updateCount = null;
          }
        }
      }
    }

    async function getPRStats(token, repos, { dateFrom, dateTo } = {}, progress) {
      const headers = {
        Authorization: `Bearer ${token}`,
        Accept: "application/vnd.github+json",
      };
      const reposArray = Array.isArray(repos)
        ? repos
        : String(repos).split(",").map(s => s.trim()).filter(Boolean);
      const totals = { totalPages: 0, fetchedPages: 0, totalReviews: 0, fetchedReviews: 0 };
      function updateOverall() {
        const denomPages = Math.max(totals.totalPages, totals.fetchedPages);
        const denomReviews = Math.max(totals.totalReviews, totals.fetchedReviews);
        const done = totals.fetchedPages + totals.fetchedReviews;
        const total = denomPages + denomReviews || 1;
        progress?.setOverall(done, total);
      }

      progress?.setStatus("Fetching pull request lists…");
      progress?.setSubLabel("Current repository pages");

      let prs = await fetchAllPRs(token, reposArray, progress, headers, totals, updateOverall);
      prs = filterPRsByDate(prs, dateFrom, dateTo);

      progress?.setStatus("Fetching reviews…");
      progress?.setSubLabel("Pull request reviews");
      progress?.setDetail(`0 of ${prs.length} reviews fetched`);
      totals.totalReviews = prs.length;
      progress?.setSub(0, totals.totalReviews);
      updateOverall();

      // Pass updateOverall and totals to fetchPRReviewsAndComments
      const reviewStats = await fetchPRReviewsAndComments(prs, headers, progress, totals, updateOverall);
      // Fetch update counts for merged PRs
      await fetchUpdateCountsForMergedPRs(prs, headers);
      const grouped = aggregateStats(prs, reviewStats.approvedSet);
      const rows = flattenStats(
        grouped,
        reviewStats.logicalReviewsByUserMonth,
        reviewStats.commentsByUserMonth,
        reviewStats.reviewTimeByUserMonth,
        reviewStats.prMapByUserMonth,
        reviewStats.approvedMapByUserMonth,
        reviewStats.mergedMapByUserMonth,
        reviewStats.reviewedMapByUserMonth,
        reviewStats.actionedCommentsByUserMonth
      );
      return rows;
    }

    async function getPRStats(token, repos, { dateFrom, dateTo } = {}, progress) {
      const headers = {
        Authorization: `Bearer ${token}`,
        Accept: "application/vnd.github+json",
      };
      const reposArray = Array.isArray(repos)
        ? repos
        : String(repos).split(",").map(s => s.trim()).filter(Boolean);
      const totals = { totalPages: 0, fetchedPages: 0, totalReviews: 0, fetchedReviews: 0 };
      function updateOverall() {
        const denomPages = Math.max(totals.totalPages, totals.fetchedPages);
        const denomReviews = Math.max(totals.totalReviews, totals.fetchedReviews);
        const done = totals.fetchedPages + totals.fetchedReviews;
        const total = denomPages + denomReviews || 1;
        progress?.setOverall(done, total);
      }

      progress?.setStatus("Fetching pull request lists…");
      progress?.setSubLabel("Current repository pages");

      let prs = await fetchAllPRs(token, reposArray, progress, headers, totals, updateOverall);
      prs = filterPRsByDate(prs, dateFrom, dateTo);

      progress?.setStatus("Fetching reviews…");
      progress?.setSubLabel("Pull request reviews");
      progress?.setDetail(`0 of ${prs.length} reviews fetched`);
      totals.totalReviews = prs.length;
      progress?.setSub(0, totals.totalReviews);
      updateOverall();

      // Pass updateOverall and totals to fetchPRReviewsAndComments
      const reviewStats = await fetchPRReviewsAndComments(prs, headers, progress, totals, updateOverall);
      // Fetch update counts for merged PRs
      await fetchUpdateCountsForMergedPRs(prs, headers);
      const grouped = aggregateStats(prs, reviewStats.approvedSet);
      const rows = flattenStats(
        grouped,
        reviewStats.logicalReviewsByUserMonth,
        reviewStats.commentsByUserMonth,
        reviewStats.reviewTimeByUserMonth,
        reviewStats.prMapByUserMonth,
        reviewStats.approvedMapByUserMonth,
        reviewStats.mergedMapByUserMonth,
        reviewStats.reviewedMapByUserMonth,
        reviewStats.actionedCommentsByUserMonth
      );
      return rows;
    }

    // Progress UI helpers
    function createProgressUI() {
      const panel = document.getElementById("progressPanel");
      const overallBar = document.getElementById("overallBar");
      const overallPct = document.getElementById("overallPct");
      const subBar = document.getElementById("subBar");
      const subPct = document.getElementById("subPct");
      const statusEl = document.getElementById("progressStatus");
      const detailEl = document.getElementById("progressDetail");
      const subLabelEl = document.getElementById("subLabel");
      const apiUsageEl = document.getElementById("apiUsage");
      let apiCount = 0;
      let apiRemaining = null;

      function open() {
        panel.classList.remove("hidden");
        panel.classList.add("flex");
      }
      function close() {
        panel.classList.add("hidden");
        panel.classList.remove("flex");
      }
      function setStatus(text) { statusEl.textContent = text; }
      function setDetail(text) { detailEl.textContent = text; }
      function setSubLabel(text) { subLabelEl.textContent = text; }
      function setOverall(done, total) {
        const pct = total > 0 ? Math.floor((done / total) * 100) : 0;
        overallBar.style.width = pct + "%";
        overallPct.textContent = pct + "%";
      }
      function setSub(done, total) {
        const pct = total > 0 ? Math.floor((done / total) * 100) : 0;
        subBar.style.width = pct + "%";
        subPct.textContent = pct + "%";
      }
      function setApiUsage(count, remaining) {
        apiUsageEl.textContent = `API requests: ${count}${remaining !== null ? `, quota remaining: ${remaining}` : ""}`;
      }
      function incApiUsage(resp) {
        apiCount++;
        if (resp && resp.headers) {
          const rem = resp.headers.get("X-RateLimit-Remaining");
          if (rem !== null) apiRemaining = rem;
        }
        setApiUsage(apiCount, apiRemaining);
      }
      function resetApiUsage() {
        apiCount = 0;
        apiRemaining = null;
        setApiUsage(apiCount, apiRemaining);
      }
      return { open, close, setStatus, setDetail, setSubLabel, setOverall, setSub, setApiUsage, incApiUsage, resetApiUsage };
    }

    // Utility: parse Link header to find last page number if present
    function parseLastPage(linkHeader) {
      if (!linkHeader) return null;
      const parts = linkHeader.split(",");
      for (const part of parts) {
        const [urlPart, relPart] = part.split(";");
        if (relPart && relPart.includes('rel="last"')) {
          const m = urlPart.match(/[?&]page=(\d+)/);
          if (m) return parseInt(m[1], 10);
        }
      }
      return null;
    }

    async function getAllPrivateRepos(token, progress) {
      const headers = {
        Authorization: `Bearer ${token}`,
        Accept: "application/vnd.github+json",
      };
      let repos = [];
      let page = 1;
      while (true) {
        const url = new URL("https://api.github.com/user/repos");
        url.searchParams.set("visibility", "private");
        url.searchParams.set("per_page", "100");
        url.searchParams.set("page", page);
        const resp = await fetch(url, { headers });
        progress?.incApiUsage(resp);
        if (!resp.ok) throw new Error(`GitHub API error (repos): ${resp.status} ${resp.statusText}`);
        const data = await resp.json();
        repos = repos.concat(data);
        if (data.length < 100) break;
        page++;
      }
      // Return as ["owner/repo", ...]
      return repos.map(r => r.full_name);
    }

    // Add showPRModal function before the form submit handler
    function showPRModal(title, prArr, isReviewList) {
      const modal = document.getElementById("prModal");
      const modalTitle = document.getElementById("prModalTitle");
      const modalContent = document.getElementById("prModalContent");
      modalTitle.textContent = title;
      modalContent.innerHTML = "";
      if (!prArr || prArr.length === 0) {
        modalContent.innerHTML = "<div class='text-gray-500'>No pull requests found.</div>";
      } else if (isReviewList) {
        // Use logical review windows if present
        let windows = [];
        prArr.forEach(item => {
          const pr = item.pr;
          const reviewer = item.review.user?.login || "unknown";
          if (pr._reviewWindows) {
            pr._reviewWindows.forEach(w => {
              if (w.reviewer === reviewer) {
                windows.push({ pr, ...w });
              }
            });
          }
        });
        // Remove duplicates
        windows = windows.filter((w, i, arr) =>
          arr.findIndex(x =>
            x.pr._repo === w.pr._repo &&
            x.pr.number === w.pr.number &&
            x.reviewer === w.reviewer &&
            x.reviewWindowStart.getTime() === w.reviewWindowStart.getTime()
          ) === i
        );
        // Sort by PR, reviewer, window start
        windows.sort((a, b) => {
          if (a.pr._repo !== b.pr._repo) return a.pr._repo.localeCompare(b.pr._repo);
          if (a.pr.number !== b.pr.number) return a.pr.number - b.pr.number;
          if (a.reviewer !== b.reviewer) return a.reviewer.localeCompare(b.reviewer);
          return a.reviewWindowStart - b.reviewWindowStart;
        });
        // Render each logical review window
        windows.forEach(w => {
          renderReviewGroup(
            w.group.map(r => ({
              pr: w.pr,
              reviewer: w.reviewer,
              review: r,
              reviewTime: new Date(r.submitted_at)
            })),
            modalContent,
            w.reviewWindowStart,
            w.reviewDurationMin
          );
        });
      } else {
        // PR list
        prArr.forEach(pr => {
          const prUrl = pr.html_url;
          const prTitle = pr.title || prUrl;
          const prNum = pr.number;
          const repo = pr._repo;
          const updates = pr._updateCount != null ? pr._updateCount : 0;
          modalContent.innerHTML += `
            <div>
              <a href="${prUrl}" target="_blank" class="text-blue-700 underline font-medium">${repo}#${prNum}: ${prTitle}</a>
              <span class="ml-2 text-xs text-gray-500">Updates: ${updates}</span>
            </div>
          `;
        });
      }
      modal.classList.remove("hidden");
      modal.classList.add("flex");
      modal.onclick = function(e) {
        if (e.target === modal) {
          modal.classList.add("hidden");
          modal.classList.remove("flex");
        }
      };
      document.getElementById("prModalClose").onclick = function(e) {
        modal.classList.add("hidden");
        modal.classList.remove("flex");
        e.stopPropagation();
      };
    }

    // Helper to render a logical review group in the modal
    function renderReviewGroup(group, modalContent, reviewWindowStart, reviewDurationMin) {
      if (!group.length) return;
      const pr = group[0].pr;
      const reviewer = group[0].reviewer;
      const prUrl = pr.html_url;
      const prTitle = pr.title || prUrl;
      const prNum = pr.number;
      const repo = pr._repo;
      // Show PR link, reviewer, and time window
      const times = group.map(g => g.reviewTime).sort((a, b) => a - b);
      const start = times[0];
      const end = times[times.length - 1];
      const timeFmt = t => t.toLocaleString();
      let actionsHtml = "";
      group.forEach(g => {
        actionsHtml += `
          <div class="ml-4 text-sm text-gray-700">
            <span class="font-semibold">${g.review.state}</span>
            <span class="ml-2">${timeFmt(g.reviewTime)}</span>
            ${g.review.body ? `<div class="ml-6 text-gray-500">${g.review.body}</div>` : ""}
          </div>
        `;
      });
      modalContent.innerHTML += `
        <div class="mb-2 p-2 rounded bg-gray-50 border border-gray-200">
          <div>
            <a href="${prUrl}" target="_blank" class="text-blue-700 underline font-medium">${repo}#${prNum}: ${prTitle}</a>
            <br/>
            <span class="ml-2 text-xs text-gray-500">Reviewer: ${reviewer}</span>
            <span class="ml-2 text-xs text-gray-500">Review window start: ${timeFmt(reviewWindowStart)} (${reviewDurationMin.toFixed(2)} min)</span>
          </div>
          ${actionsHtml}
        </div>
      `;
    }

    // Add this helper function before its first usage (above the PR/Review table rendering code)
    function renderUserCell(userObj) {
      if (!userObj) return "";
      return `<span class="font-semibold">${userObj.login}</span>`;
    }

    async function getAllPrivateRepos(token, progress) {
      const headers = {
        Authorization: `Bearer ${token}`,
        Accept: "application/vnd.github+json",
      };
      let repos = [];
      let page = 1;
      while (true) {
        const url = new URL("https://api.github.com/user/repos");
        url.searchParams.set("visibility", "private");
        url.searchParams.set("per_page", "100");
        url.searchParams.set("page", page);
        const resp = await fetch(url, { headers });
        progress?.incApiUsage(resp);
        if (!resp.ok) throw new Error(`GitHub API error (repos): ${resp.status} ${resp.statusText}`);
        const data = await resp.json();
        repos = repos.concat(data);
        if (data.length < 100) break;
        page++;
      }
      // Return as ["owner/repo", ...]
      return repos.map(r => r.full_name);
    }

    // Handle form
    document.getElementById("prForm").addEventListener("submit", async (e) => {
      e.preventDefault();
      const token = document.getElementById("token").value;
      const repoInput = document.getElementById("repo").value.trim();
      let dateFrom = document.getElementById("dateFrom").value;
      let dateTo = document.getElementById("dateTo").value;

      // Set local time, then convert to UTC ISO string
      if (dateFrom) {
        const d = new Date(dateFrom);
        d.setHours(0, 0, 0, 0);
        dateFrom = new Date(d.getTime() - d.getTimezoneOffset() * 60000).toISOString();
      }
      if (dateTo) {
        const d = new Date(dateTo);
        d.setHours(23, 59, 59, 999);
        dateTo = new Date(d.getTime() - d.getTimezoneOffset() * 60000).toISOString();
      }

      const resultsDiv = document.getElementById("results");
      const prTablePanel = document.getElementById("prTablePanel");
      const reviewTablePanel = document.getElementById("reviewTablePanel");
      resultsDiv.classList.add("hidden");
      prTablePanel.classList.add("hidden");
      reviewTablePanel.classList.add("hidden");

      const progress = createProgressUI();
      progress.open();
      progress.resetApiUsage();

      try {
        let repos;
        if (!repoInput) {
          progress.setStatus("Fetching all private repositories…");
          repos = await getAllPrivateRepos(token, progress);
          if (repos.length === 0) throw new Error("No private repositories found for this token.");
          if (repos.length > 5) {
            progress.close();
            if (!confirm(`You have ${repos.length} private repositories. This may take a long time and hit API rate limits. Proceed?`)) {
              return;
            }
            progress.open();
          }
        } else {
          repos = repoInput.split(",").map(s => s.trim()).filter(Boolean);
        }

        const stats = await getPRStats(token, repos, { dateFrom, dateTo }, progress);

        // Get table body elements
        const prTableBody = document.getElementById("prTableBody");
        const reviewTableBody = document.getElementById("reviewTableBody");
        
        // Clear existing content
        prTableBody.innerHTML = "";
        reviewTableBody.innerHTML = "";

        // Split stats into PR rows and Review rows
        const prRows = [];
        const reviewRows = [];
        for (const r of stats) {
          prRows.push({ user: r.user, month: r.month, count: r.count, approved: r.approved, merged: r.merged, prList: r.prList, approvedList: r.approvedList, mergedList: r.mergedList });
          reviewRows.push({ user: r.user, month: r.month, reviewed: r.reviewed, avgCommentsPerReview: r.avgCommentsPerReview, avgReviewTime: r.avgReviewTime, reviewedList: r.reviewedList, avgActionedComments: r.avgActionedComments, actionedCount: r.actionedCount });
        }

        // Sort both tables by user name ascending
        prRows.sort((a, b) => a.user.localeCompare(b.user));
        reviewRows.sort((a, b) => a.user.localeCompare(b.user));

        // Group by user for summary rows
        function groupRows(rows, keys) {
          const byUser = new Map();
          for (const r of rows) {
            const entry = byUser.get(r.user) || { months: [], totals: {} };
            entry.months.push(r);
            keys.forEach(k => {
              entry.totals[k] = (entry.totals[k] || 0) + (parseFloat(r[k]) || 0);
            });
            byUser.set(r.user, entry);
          }
          return byUser;
        }

        // PR Table
        const prByUser = groupRows(prRows, ["count", "merged"]);
        for (const [user, entry] of prByUser.entries()) {
          if ((entry.totals.count || entry.totals.merged)) {
            // NEW: aggregate line stats across merged PRs (all months)
            const totalLinesChangedAll = entry.months.reduce((sum, m) => sum + (Array.isArray(m.mergedList) ? m.mergedList.reduce((s, pr) => s + (pr._linesChanged || 0), 0) : 0), 0);
            // Existing total updates & merge time logic
            const totalUpdatesAll = entry.months.reduce((sum, m) => {
              if (Array.isArray(m.mergedList)) {
                return sum + m.mergedList.reduce((s, pr) => s + (pr._updateCount ?? 0), 0);
              }
              return sum;
            }, 0);
            let totalMergeTimeAll = 0; let mergedCountAll = 0;
            entry.months.forEach(m => {
              if (Array.isArray(m.mergedList)) {
                m.mergedList.forEach(pr => {
                  if (pr.created_at && pr.merged_at) {
                    totalMergeTimeAll += (new Date(pr.merged_at) - new Date(pr.created_at)) / 3600000;
                    mergedCountAll++;
                  }
                });
              }
            });
            const avgMergeTimeAll = mergedCountAll > 0 ? (totalMergeTimeAll / mergedCountAll).toFixed(2) : "0.00";
            const tr = document.createElement("tr");
            tr.className = "summary-row cursor-pointer bg-gray-50 hover:bg-gray-100";
            tr.dataset.user = user;
            tr.innerHTML = `
              <td class="p-3 border font-medium flex items-center">
                <span class="mr-2 inline-block">
                  <svg data-icon class="w-3 h-3 inline-block align-middle transition-transform" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
                    <path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 111.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd"/>
                  </svg>
                </span>
                ${(() => { const userObj = entry.months[0]?.prList?.[0]?.user || { login: user }; const avatar = userObj.avatar_url ? `<img src="${userObj.avatar_url}" class="inline-block w-6 h-6 rounded-full align-middle mr-2" alt="${userObj.login}">` : ""; return `${avatar}<span class=\"font-semibold\">${userObj.login}</span>`; })()}
              </td>
              <td class="p-3 border text-gray-500">All</td>
              <td class="p-3 border font-semibold pr-cell" data-type="count" data-user="${user}" data-month="all" style="cursor:pointer">${entry.totals.count}</td>
              <td class="p-3 border font-semibold pr-cell" data-type="merged" data-user="${user}" data-month="all" style="cursor:pointer">${entry.totals.merged}</td>
              <td class="p-3 border font-semibold">${(totalUpdatesAll/entry.totals.merged).toFixed(2)}</td>
              <td class="p-3 border font-semibold">${totalLinesChangedAll}</td>
              <td class="p-3 border font-semibold">${avgMergeTimeAll}</td>`;
            prTableBody.appendChild(tr);
            // Detail rows
            const monthsSorted = entry.months.sort((a, b) => a.month.localeCompare(b.month));
            for (const m of monthsSorted) {
              let totalMergeTimeMonth = 0; let mergedCountMonth = 0; let totalUpdatesMonth = 0; let linesChangedMonth = 0;
              if (Array.isArray(m.mergedList)) {
                m.mergedList.forEach(pr => {
                  if (pr.created_at && pr.merged_at) {
                    totalMergeTimeMonth += (new Date(pr.merged_at) - new Date(pr.created_at)) / 3600000;
                    mergedCountMonth++;
                  }
                  totalUpdatesMonth += pr._updateCount ?? 0;
                  linesChangedMonth += pr._linesChanged || 0;
                });
              }
              const avgMergeTimeMonth = mergedCountMonth > 0 ? (totalMergeTimeMonth / mergedCountMonth).toFixed(2) : "0.00";
              const dtr = document.createElement("tr");
              dtr.className = "detail-row hidden";
              dtr.dataset.parent = user;
              dtr.innerHTML = `
                <td class="p-3 border pl-8 text-gray-500"></td>
                <td class="p-3 border">${m.month}</td>
                <td class="p-3 border pr-cell" data-type="count" data-user="${user}" data-month="${m.month}" style="cursor:pointer">${m.count}</td>
                <td class="p-3 border pr-cell" data-type="merged" data-user="${user}" data-month="${m.month}" style="cursor:pointer">${m.merged}</td>
                <td class="p-3 border">${totalUpdatesMonth}</td>
                <td class="p-3 border">${linesChangedMonth}</td>
                <td class="p-3 border">${avgMergeTimeMonth}</td>`;
              prTableBody.appendChild(dtr);
            }
          }
        }

        // Peer Review Table
        const reviewByUser = groupRows(reviewRows, ["reviewed", "actionedCount"]);
        for (const [user, entry] of reviewByUser.entries()) {
          if ((entry.totals.reviewed)) {
            const totalReviewed = entry.totals.reviewed;
            const totalActioned = entry.totals.actionedCount || 0;
            const avgActionedOverall = totalReviewed ? (totalActioned / totalReviewed).toFixed(2) : "0.00";
            // Use total raw values (reconstructed) instead of per-month average to account for months with 0
            const totalComments = entry.months.reduce((s,m)=> s + (m.reviewed * parseFloat(m.avgCommentsPerReview)),0);
            const totalReviewTime = entry.months.reduce((s,m)=> s + (m.reviewed * parseFloat(m.avgReviewTime)),0);
            const avgComments = totalReviewed ? (totalComments / totalReviewed).toFixed(2) : "0.00";
            const avgReviewTime = totalReviewed ? (totalReviewTime / totalReviewed).toFixed(2) : "0.00";
            const tr = document.createElement("tr");
            tr.className = "summary-row cursor-pointer bg-gray-50 hover:bg-gray-100";
            tr.dataset.user = user;
            tr.innerHTML = `
              <td class="p-3 border font-medium flex items-center">
                <span class="mr-2 inline-block">
                  <svg data-icon class="w-3 h-3 inline-block align-middle transition-transform" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
                    <path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 111.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd"/>
                  </svg>
                </span>
                ${(() => { const userObj = entry.months[0]?.reviewedList?.[0]?.review?.user || { login: user }; const avatar = userObj.avatar_url ? `<img src="${userObj.avatar_url}" class="inline-block w-6 h-6 rounded-full align-middle mr-2" alt="${userObj.login}">` : ""; return `${avatar}${renderUserCell(userObj)}`; })()}
              </td>
              <td class="p-3 border text-gray-500">All</td>
              <td class="p-3 border font-semibold pr-cell" data-type="reviewed" data-user="${user}" data-month="all" style="cursor:pointer">${totalReviewed}</td>
              <td class="p-3 border font-semibold">${avgComments}</td>
              <td class="p-3 border font-semibold">${avgReviewTime}</td>
              <td class="p-3 border font-semibold">${avgActionedOverall}</td>`;
            reviewTableBody.appendChild(tr);
            const monthsSorted = entry.months.sort((a,b)=>a.month.localeCompare(b.month));
            for (const m of monthsSorted) {
              const dtr = document.createElement("tr");
              dtr.className = "detail-row hidden";
              dtr.dataset.parent = user;
              dtr.innerHTML = `
                <td class="p-3 border pl-8 text-gray-500"></td>
                <td class="p-3 border">${m.month}</td>
                <td class="p-3 border pr-cell" data-type="reviewed" data-user="${user}" data-month="${m.month}" style="cursor:pointer">${m.reviewed}</td>
                <td class="p-3 border">${m.avgCommentsPerReview}</td>
                <td class="p-3 border">${m.avgReviewTime}</td>
                <td class="p-3 border">${m.avgActionedComments}</td>`;
              reviewTableBody.appendChild(dtr);
            }
          }
        }

        // Attach click handlers for PR modal (PR table)
        prTableBody.querySelectorAll('.pr-cell').forEach(cell => {
          cell.onclick = function(e) {
            // Only open modal for detail rows, not aggregate (summary) rows
            const parentRow = cell.closest('tr');
            if (parentRow && parentRow.classList.contains('summary-row')) return;
            const type = cell.dataset.type;
            const user = cell.dataset.user;
            const month = cell.dataset.month;
            let prArr = [];
            let title = "";
            let entry = prByUser.get(user);
            if (!entry) return;
            if (month === "all") {
              prArr = [];
              entry.months.forEach(m => {
                if (type === "count") prArr = prArr.concat(m.prList);
                else if (type === "approved") prArr = prArr.concat(m.approvedList);
                else if (type === "merged") prArr = prArr.concat(m.mergedList);
              });
              title = `${type.charAt(0).toUpperCase() + type.slice(1)} PRs by ${user} (all months)`;
            } else {
              const monthEntry = entry.months.find(x => x.month === month);
              if (monthEntry) {
                if (type === "count") prArr = monthEntry.prList;
                else if (type === "approved") prArr = monthEntry.approvedList;
                else if (type === "merged") prArr = monthEntry.mergedList;
                title = `${type.charAt(0).toUpperCase() + type.slice(1)} PRs by ${user} in ${month}`;
              }
            }
            showPRModal(title, prArr, false);
          };
        });

        // Attach click handlers for review modal (Review table)
        reviewTableBody.querySelectorAll('.pr-cell[data-type="reviewed"]').forEach(cell => {
          cell.onclick = function(e) {
            // Only open modal for detail rows, not aggregate (summary) rows
            const parentRow = cell.closest('tr');
            if (parentRow && parentRow.classList.contains('summary-row')) return;
            const user = cell.dataset.user;
            const month = cell.dataset.month;
            let prArr = [];
            let title = "";
            let entry = reviewByUser.get(user);
            if (!entry) return;
            if (month === "all") {
              prArr = [];
              entry.months.forEach(m => prArr = prArr.concat(m.reviewedList));
              title = `PRs reviewed by ${user} (all months)`;
            } else {
              const monthEntry = entry.months.find(x => x.month === month);
              if (monthEntry) {
                prArr = monthEntry.reviewedList;
                title = `PRs reviewed by ${user} in ${month}`;
              }
            }
            showPRModal(title, prArr, true);
          };
        });

        // Delegate click to toggle details per user (rotates the SVG chevron) for both tables
        function bindToggle(tableBody) {
          if (!tableBody.dataset.toggleBound) {
            tableBody.addEventListener("click", (evt) => {
              const row = evt.target.closest("tr.summary-row");
              if (!row) return;
              const user = row.dataset.user;
              const shouldOpen = row.dataset.expanded !== "1";
              tableBody.querySelectorAll(`tr.detail-row[data-parent="${CSS.escape(user)}"]`).forEach(r => {
                if (shouldOpen) r.classList.remove("hidden"); else r.classList.add("hidden");
              });
              const icon = row.querySelector("[data-icon]");
              if (icon) icon.style.transform = shouldOpen ? "rotate(90deg)" : "rotate(0deg)";
              row.dataset.expanded = shouldOpen ? "1" : "0";
            });
            tableBody.dataset.toggleBound = "1";
          }
        }
        bindToggle(prTableBody);
        bindToggle(reviewTableBody);

        // Show/hide table panels based on rows
        if (prRows.length > 0 || reviewRows.length > 0) {
          resultsDiv.classList.remove("hidden");
        } else {
          resultsDiv.classList.add("hidden");
        }
        if (prRows.length > 0) {
          prTablePanel.classList.remove("hidden");
        } else {
          prTablePanel.classList.add("hidden");
        }
        if (reviewRows.length > 0) {
          reviewTablePanel.classList.remove("hidden");
        } else {
          reviewTablePanel.classList.add("hidden");
        }
      } catch (err) {
        alert(err.message);
      } finally {
        progress.close();
      }
    });

  // Removed obsolete dark mode toggle script (themeToggle element not present)
  </script>
</body>
</html>